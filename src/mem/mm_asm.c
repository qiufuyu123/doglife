
 __asm__(
    ".text\n"
    ".globl _get_el\n"
    ".globl _rebase_pc\n"
    ".globl _set_vbar_el1\n"
    ".globl __enable_interrupts\n"
    ".globl __disable_interrupts\n"
    ".globl _get_mpidr\n"
    ".globl _get_migsts\n"
    ".globl _set_migsts\n"
    ".globl _get_mmfr0\n"
    ".globl _invalidate_icache\n"
    ".globl _enable_mmu_el1\n"
    ".globl _disable_mmu_el1\n"
    ".globl _get_ticks\n"
    ".globl _copy_safe_internal\n"
    ".globl _copy_retn\n"
    ".globl _pan_on\n"
    ".globl _pan_off\n"
    ".globl _cache_invalidate\n"
    ".globl _cache_clean_and_invalidate\n"
    ".globl _cache_clean\n"
    ".globl _cache_clean_and_invalidate_all\n"

    "_get_el:\n"
    "    mrs x0, currentel\n"
    "    lsr x0, x0, 2\n"
    "    ret\n"
    "_rebase_pc:\n"
    "    add sp, sp, x0\n"
    "    add x29, x29, x0\n"
    "    add x30, x30, x0\n"
    "    ret\n"

    "_set_vbar_el1:\n"
    "    msr vbar_el1, x0\n"
    "    isb\n"
    "    ret\n"

    "__enable_interrupts:\n"
    "    msr daifclr,#0xf\n"
    "    isb\n"
    "    ret\n"
    "__disable_interrupts:\n"
    "    msr daifset,#0xf\n"
    "    isb\n"
    "    ret\n"

    "_get_mpidr:\n"
    "    mrs x0, MPIDR_EL1\n"
    "    ret\n"
    "_get_migsts:\n"
    "    mrs x0, S3_4_c15_c0_4\n"
    "    ret\n"
    "_set_migsts:\n"
    "    msr S3_4_c15_c0_4, x0\n"
    "    ret\n"
    "_get_mmfr0:\n"
    "    mrs x0, id_aa64mmfr0_el1\n"
    "    ret\n"
    "_invalidate_icache:\n"
    "    dsb ish\n"
    "    ic iallu\n"
    "    dsb ish\n"
    "    isb\n"
    "    ret\n"

    "_enable_mmu_el1:\n"
    "    dsb sy\n"
    "    msr mair_el1, x2\n"
    "    msr tcr_el1, x1\n"
    "    msr ttbr0_el1, x0\n"
    "    msr ttbr1_el1, x3\n"
    "    isb sy\n"
    "    tlbi vmalle1\n"
    "    isb sy\n"
    "    ic iallu\n"
    "    isb sy\n"
    "    mrs x3, sctlr_el1\n"
    "    orr x3, x3, #1\n"
    "    orr x3, x3, #4\n"
    "    orr x3, x3, #0x800000\n" // enable SPAN if possible
    "    and x3, x3, #(~2)\n"
    "    msr sctlr_el1, x3\n"
    "    ic iallu\n"
    "    dsb sy\n"
    "    isb sy\n"
    "    ret\n"

    "_disable_mmu_el1:\n"
    "    dsb sy\n"
    "    isb sy\n"
    "    mrs x3, sctlr_el1\n"
    "    and x3, x3, #(~1)\n"
    "    and x3, x3, #(~4)\n"
    "    msr sctlr_el1, x3\n"
    "    tlbi vmalle1\n"
    "    ic iallu\n"
    "    dsb sy\n"
    "    isb sy\n"
    "    ret\n"

    "_get_ticks:\n"
    "    isb sy\n"
    "    mrs x0, cntpct_el0\n"
    "    ret\n"
    "_pan_on:\n"
    ".long 0xd500419f\n"
    "    ret\n"
    "_pan_off:\n"
    ".long 0xd500409f\n"
    "    ret\n"

    "_copy_trap_internal:\n"
    "    stp x29, x30, [sp, -0x10]!\n"
    "    mov x4, xzr\n"
    "1:\n"
    "    cbz x2, 2f\n"
    "    ldrb w5, [x1], #1\n"
    "    strb w5, [x0], #1\n"
    "    sub x2, x2, #1\n"
    "    add x4, x4, #1\n"
    "    b 1b\n"
    "2:\n"
    "_copy_retn:\n"
    "    mov x0, x4\n"
    "    ldp x29, x30, [sp], 0x10\n"
    "    ret\n"

    "_cache_invalidate:\n"
    "   dsb sy\n"
    "   isb\n"
    "   add x1, x0, x1\n"
    "1:\n"
    "   dc ivac, x0\n"
    "   add x0, x0, 0x40\n"
    "   cmp x0, x1\n"
    "   b.lo 1b\n"
    "   dsb sy\n"
    "   isb\n"
    "   ret\n"

    "_cache_clean_and_invalidate:\n"
    "_cache_clean:\n" // invalidates too, because Apple
    "   dsb sy\n"
    "   isb\n"
    "   add x1, x0, x1\n"
    "1:\n"
    "   dc civac, x0\n"
    "   add x0, x0, 0x40\n"
    "   cmp x0, x1\n"
    "   b.lo 1b\n"
    "   dsb sy\n"
    "   isb\n"
    "   ret\n"

    "_cache_clean_and_invalidate_all:\n"
    "   dsb sy\n"
    "   isb\n"
    "   mrs x1, clidr_el1\n"
    "   and x2, x1, 0xf\n"
    "   cbz x2, 5f\n" // No cache?
    "   mov w0, 0\n" // w0 = Cache level
    "1:\n"
    "   lsr x1, x1, 4\n"
    "   and x2, x1, 0xf\n"
    "   cbz x2, 2f\n"
    "   add x0, x0, 2\n"
    "   cmp x0, 14\n"
    "   b.eq 2f\n"
    "   b 1b\n"
    "2:\n"
    "   msr csselr_el1, x0\n"
    "   isb\n"
    "   mrs x5, ccsidr_el1\n"
    "   ubfx w3, w5, 13, 15\n" // w3 = Sets
    "   ubfx w5, w5, 3, 10\n"  // w5 = Ways
    "   clz w6, w5\n" // lsb of ways
    "   mov w4, 0\n" // w4 = Way counter
    "3:\n"
    "   mov w2, 0\n" // w2 = Set counter
    "4:\n"
    "   lsl w1, w4, w6\n"
    "   bfi w1, w2, 6, 13\n"
    "   orr w1, w1, w0\n"
    "   dc cisw, x1\n"
    "   add w2, w2, 1\n"
    "   cmp w2, w3\n"
    "   b.ls 4b\n"
    "   add w4, w4, 1\n"
    "   cmp w4, w5\n"
    "   b.ls 3b\n"
    "   dsb sy\n"
    "   isb\n"
    "5:\n"
    "   ret\n"
);